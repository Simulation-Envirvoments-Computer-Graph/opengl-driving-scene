# Build Instructions:
This project requires the following libraries:
- libbullet-dev
- libassimp-dev
- libfreetype6-dev
- libglfw3-dev
- libglm-dev

After installing the above, use the following commands to build the program:
- mkdir Build
- cd Build
- cmake ..
- make

Then run the program like so:
- cd final
- ./final


# Keys:
- `ESC`: Exit program
- `WASD`: Car movement
- `SPACE`: Brake
- `R`: Reset car and camera extrinsics and active forces
- Arrow Keys: Rotate camera around car
- `Q`/`E`: Increase/decrease distance between camera and car
- `F`: toggle fog (also toggles skybox and changes color of text)
- `T`: toggle debug draw (Bullet physics engine debug lines, as well as custom ones for light positions/directions)
- `G`: toggles relative rotational follow of camera and car
- `P`: Change camera projection mode (although it no longer really makes sense
     to use anything besides perspective, which is the default)

# Functionality:
- Shaders: every rendered aspect of the program
  (the skybox, the text, the debug lines, and the world geometry) is created using
  shaders.
- Bullet physics engine: each of the objects within the scene has
  an associated rigidbody. Furthermore, each of these rigidbodies have associated
  geometries used for collision detection. Specifically, the terrain uses a height
  field, the walls use a geometry generated by the underlying triangle mesh, the
  streetlights used cylinders, and the vehicle uses a compound geometry consisting
  of a box for the chassis and cylinders for the tires. Bullet provides built-in
  support for vehicle physics; as such, the results are fairly realistic.
- Asset import: The car model is imported. Importing is done using `assimp`. Rendering involves
  (1) excluding the low-poly mesh that was meant for collision detection, (2) centering
  the wheels at the mesh level (i.e., vertex position attributes) by subtracting
  the average vertex position from each vertex, and (3) obtaining the OpenGL representation
  of the model matrix from the Bullet vehicle for both the chassis and the individual
  wheels and render all of them individually.
- Height map: The mountainous terrain is generated
  with a 256x256 height map. Each of the pixels corresponds to a height, and
  the geometry and normals are constructed from this height data. The height
  map was specifically chosen to have high-intensity pixels in the center and
  low-intensity pixels on the edges; this provides the perfect setup for a race course
  near the edge of the screen.
- Custom-generated geometry: The vertex positions, normals, and texture coordinates for the streetlights and walls are
  all generated programmatically. The streetlight uses two textures (one for the post, one for the bulb), but the
  walls only use one (each "segment", which is a locally-linear approximation of the ellipse, contains one logo;
  the texture contains three logos, so each segment has a range of 1/3 in the s-coordinate).
- Debugging line drawer: The debug drawer extends the Bullet btIDebugDraw interface. It provides
  a simple line drawing function; this function is consumed by Bullet to draw the AABB for
  collision geometries. Moreover, I use this facility for my own purposes; right now,
  the position and direction of each spotlight and point light are shown using these debug
  lines.
- Camera controller: The camera includes a number of subtle features. One is
  "relative rotational follow". This works by calculating the Y-axis rotation
  of the car and adding the theta and phi values (controlled using the arrow keys)
  on top of that. This provides a more natural feeling while making turns, but still
  gives ample freedom to the user. Another feature is a simplistic form of smoothing:
  rather than simply following the car, the camera follows a moving-average of the car's
  position. This reduces jitter and looks arguably looks nice when the scene is reset and
  the camera smoothly returns to the starting position.
- Project setup: Extensions of the utility files, creation of inheritable classes such as
  GameObject, and debug drawing capabilities all culminate in a scalable project design.


# Acknowledgments:
- Portions of code taken from `https://learnopengl.com/`.
- None of the artwork is mine.

# Note
The program is unfortunately not very optimized. It runs at 400FPS on my desktop but only ~10FPS
on my laptop. If you experience FPS problems, one potential solution is to disable the debugging lines (press t).
Each line creates a draw call, which is highly inefficient (the more efficient solution would be to
accumulate line geometry for each frame and then create a single draw call at the end).
In the event of extremely low FPS, the physics may become slightly sluggish. This is because the
simulation is capped at 5 substeps per frame, where each substep is a fixed time value. The number
of substeps run each frame is adaptable based on the time difference from the previous frame, but
the cap exists to ensure that the program does not get caught in the cycle of taking a long
time to perform each substep which results in a large time difference that causes the next frame to have even
more substeps to perform. With all that being said, the physics are reasonable (if not perfect) at 10FPS.
Moreover, they behave as expected under high FPS situations.
